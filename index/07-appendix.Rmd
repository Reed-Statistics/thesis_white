`r if(knitr:::is_latex_output()) '\\appendix'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendix {-}'` 


# The First Appendix

This appendix includes the code used to create the estimates used in this thesis. Notably, we include both the helper functions created to run the analyses and the implementation of these helper functions.

## Helper Functions

### The Sample Mean

```{r sample-mean, eval = F}
direct_estimate <- function(data, response, small_area) {
  # Load packages
  library(sae)
  
  # Create dataframe
  dat <- data.frame(
    y = data[[response]],
    small_area = data[[small_area]]
  )
  
  # Compute estimate
  sae::direct(y = dat$y,
              dom = dat$small_area,
              replace = TRUE)
}
```

### Post-Stratification

```{r post-strat, eval = F}
postStrat2_bio <- function(data, strata) {
  est <- mase::postStrat(y = data[["BIOLIVE_TPA"]],
                  x_sample = data[["FIAstrat"]],
                  x_pop = strata,
                  data_type = "totals",
                  var_est = T)
  return(data.frame(ps_est = est$pop_mean, sd = sqrt(est$pop_mean_var)))
}
postStrat2_ba <- function(data, strata) {
  est <- mase::postStrat(y = data[["BALIVE_TPA"]],
                  x_sample = data[["FIAstrat"]],
                  x_pop = strata,
                  data_type = "totals",
                  var_est = T)
  return(data.frame(ps_est = est$pop_mean, sd = sqrt(est$pop_mean_var)))
}

postStrat2_voln <- function(data, strata) {
  est <- mase::postStrat(y = data[["VOLNLIVE_TPA"]],
                  x_sample = data[["FIAstrat"]],
                  x_pop = strata,
                  data_type = "totals",
                  var_est = T)
  return(data.frame(ps_est = est$pop_mean, sd = sqrt(est$pop_mean_var)))
}

postStrat2_cnt <- function(data, strata) {
  est <- mase::postStrat(y = data[["CNTLIVE_TPA"]],
                  x_sample = data[["FIAstrat"]],
                  x_pop = strata,
                  data_type = "totals",
                  var_est = T)
  return(data.frame(ps_est = est$pop_mean, sd = sqrt(est$pop_mean_var)))
}

postStrat2_x <- function(data, strata) {
  est <- mase::postStrat(y = data[["nlcd11"]],
                  x_sample = data[["FIAstrat"]],
                  x_pop = strata,
                  data_type = "totals",
                  var_est = T)
  return(data.frame(ps_est_x = est$pop_mean))
}
```

### Hierarchical Bayesian Unit-Level

```{r, eval = F}
hb_unit <- function(data, formula, small_area, pop_data) {
  # Load packages
  library(tidyverse)
  library(hbsae)
  
  # Create model frame
  model_frame <- model.frame(formula, data) %>%
    dplyr::mutate(small_area = data[[small_area]])
  colnames(model_frame) <- c("y", "x", "small_area")
  
  # Area population sizes
  pop_size <- pop_data %>%
    dplyr::filter(zoneid %in% model_frame$small_area) %>%
    dplyr::select(zoneid, sum) %>%
    dplyr::rename(pop_size = sum) %>%
    dplyr::select(pop_size)
  
  # Create population means matrix
  pop_means <- pop_data %>%
    dplyr::filter(zoneid %in% model_frame$small_area) %>%
    dplyr::select(zoneid, mean) %>%
    dplyr::rename(x = mean) %>%
    column_to_rownames("zoneid")
  
  # Create lambda
  anova <- aov(y ~ small_area, data = model_frame)
  l <- summary(anova)[[1]]["small_area", "F value"]
  
  # Fit the model
  mod <- fSAE.Unit(
    y = model.frame(formula, data = data)[, 1],
    X = data.frame(X = model.frame(formula, data = data)[,-1]),
    area = data[[small_area]],
    Narea = pop_size$pop_size,
    Xpop = pop_means,
    fpc = TRUE,
    lambda0 = l,
    silent = T
  )

  # Calculate CoV
  mean_y <- model_frame %>%
    dplyr::group_by(small_area) %>%
    dplyr::summarise(mean_y = mean(y))
  CoV <- hbsae::SE(mod) / mean_y$mean_y

  ## Add to model object
  mod$CoV <- CoV

  # Print model
  mod
}
```

### Hierarchical Bayesian Area-Level

```{r, eval = F}
hb_area <- function(data, formula, small_area, pop_data) {
  # Load packages
  library(tidyverse)
  library(hbsae)
  
  # Create unnamed model frame (to call correct y var in a filter)
  mf <- model.frame(formula, data)
  
  # Create model frame
  model_frame <- model.frame(formula, data) %>%
    dplyr::mutate(small_area = data[[small_area]])
  colnames(model_frame) <- c("y", "x", "small_area")
  
  # Direct X
  X <- pop_data %>%
    dplyr::filter(zoneid %in% model_frame$small_area) %>%
    dplyr::select(zoneid, mean) %>%
    dplyr::rename(mean_x = mean,
                  small_area = zoneid) %>%
    dplyr::arrange(small_area)

  # Compute direct estimate
  mean <- direct_estimate(model_frame, "y", "small_area") %>%
    dplyr::mutate(var = SD^2)
  
  dir <- ps_dat %>%
    filter(response %in% colnames(mf)[1],
           province %in% unique(data$province)) %>%
    arrange(subsection)
  
  # Create lambda
  anova <- aov(y ~ small_area, data = model_frame)
  l <- summary(anova)[[1]]["small_area", "F value"]

  # Fit the model
  mod <- fSAE.Area(
    est.init = dir$est,
    var.init = dir$var,
    X = X %>% dplyr::select(mean_x),
    lambda0 = l
  )

  # Calculate CoV
   CoV <- hbsae::SE(mod) / mean$Direct
   mod$CoV <- CoV

  # Print model
  mod
}
```

### Frequentist Unit-Level

```{r, eval = F}
freq_unit <- function(data, formula, small_area, pop_data) {
  # Load packages
  library(tidyverse)
  library(sae)
  
  # Create model frame
  model_frame <- model.frame(formula, data) %>%
    dplyr::mutate(small_area = data[[small_area]])
  colnames(model_frame) <- c("y", "x", "small_area")
  
  # Area population sizes
  pop_size <- pop_data %>%
    dplyr::filter(zoneid %in% model_frame$small_area) %>%
    dplyr::select(zoneid, sum) %>%
    dplyr::rename(pop_size = sum,
                  small_area = zoneid)
  
  # Create population means matrix
  meanxpop <- pop_data %>%
    dplyr::filter(zoneid %in% model_frame$small_area) %>%
    dplyr::select(zoneid, mean) %>%
    dplyr::rename(x = mean,
                  small_area = zoneid)
  
  # Fit the model
  mod <- eblupBHF(
    formula = model_frame$y ~ model_frame$x,
    dom = model_frame$small_area,
    meanxpop = meanxpop,
    popnsize = pop_size
  )
  mod
}
```

### Frequentist Area-Level

```{r, eval = F}
freq_area <- function(data, formula, small_area, pop_data) {
  # Load packages
  library(tidyverse)
  library(sae)
  
  # Create model frame
  model_frame <- model.frame(formula, data) %>%
    dplyr::mutate(small_area = data[[small_area]])
  colnames(model_frame) <- c("y", "x", "small_area")
  model_frame
  
  mf <- model.frame(formula, data)
  
  dir <- ps_dat %>% # need to have the ps_dat object in global env...
    filter(response %in% colnames(mf)[1],
           province %in% unique(data$province)) %>%
    arrange(subsection)
  
  # Direct X
  X <- pop_data %>%
    dplyr::filter(zoneid %in% model_frame$small_area) %>%
    dplyr::select(zoneid, mean) %>%
    dplyr::rename(mean_x = mean,
                  small_area = zoneid) %>%
    dplyr::arrange(small_area)
  
  # Join pop and dir
  dat <- dir %>%
    left_join(X, by = c("subsection" = "small_area"))

  # Fit the model
  mod <- sae::mseFH(formula = dat$est ~ dat$mean_x,
                      vardir = dat$var)
  mod
  
}
```

### Coeffiicent of Variation Functions

```{r, eval = F}
hb_CoV <- function(data) {
  # Load packages
  library(tidyverse)
  library(hbsae)
  
  # Grab CoV
  data$CoV
}

freq_unit_CoV <- function(data, formula, small_area, pop_data, B = 100) {
  # Load packages
  library(tidyverse)
  library(sae)
  
  # Create empty items for looping
  boots <- list()
  fit <- list()
  mean_df <- list()
  final <- data.frame()
  
  # Create model frame
  model_frame <- model.frame(formula, data) %>%
    dplyr::mutate(small_area = data[[small_area]])
  colnames(model_frame) <- c("y", "x", "small_area")
  
  # Nest by small area
  data_nested <- model_frame %>%
    mutate(id = small_area) %>%
    group_by(small_area) %>%
    nest()
  
  # Bootstrap
  for(i in 1:B){
    for(j in 1:length(unique(model_frame$small_area))) {
      boots[[j]] <- sample_n(
        data_nested[[2]][[j]],
        size = length(data_nested[[2]][[j]]$y),
        replace = TRUE
      )
      boots_df <- bind_rows(boots) 
    }
    
    fit[[i]] <- freq_unit(boots_df, y ~ x, "id", pop_data)
    
    mean_df[[i]] <- data.frame(fitted = fit[[i]]$eblup$eblup,
                               subsection = fit[[i]]$eblup$domain)
    if (i %% 50 == 1) {
      print(i)
    }
  }
  
  # Create final output
  final <- bind_rows(mean_df) %>%
    group_by(subsection) %>%
    summarize(sd = sd(fitted, na.rm = TRUE))
  mean_y <- model_frame %>%
    dplyr::group_by(small_area) %>%
    dplyr::summarise(mean_y = mean(y, na.rm = TRUE))
  
  COV <- final$sd / mean_y$mean_y
  names(COV) <- final$subsection
  
  COV
}
```







